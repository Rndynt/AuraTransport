You are a senior full-stack implementer. Scope: FIX trip scheduling flow so brand-new trips always show a Stop Schedule and “Derive Legs” never fails silently.

GOAL
- When a new Trip is created, auto-initialize its `trip_stop_times` from the selected Trip Pattern’s ordered stops.
- Provide a clear “Stop Schedule” editor that lets the operator set times, then automatically derive legs and (optionally) precompute seat inventory once valid.
- Show precise error messages if stop times are incomplete or non-monotonic.

CHANGES

BACKEND
1) On `POST /api/trips` (create Trip):
   - Immediately create `trip_stop_times` rows by copying the pattern’s stops:
     {trip_id, stop_id, stop_sequence, arrive_at=null, depart_at=null, dwell_seconds=0}
   - Return the created Trip normally. This guarantees the Scheduling dialog always has rows to render.

2) Add validation helper `validateTripStopTimes(tripId)`:
   - At least 2 stops.
   - For sequence i:
     - If i=1: `depart_at` must be present (arrive_at may be null).
     - If 1<i<N: if either `arrive_at` or `depart_at` is provided, both must be provided.
     - If i=N: `arrive_at` must be present (depart_at may be null).
   - Times must be chronological:
     depart(i) ≤ arrive(i+1) and arrive(i) ≥ depart(i-1)+dwell(i-1), etc.
   - Return a structured list of errors with the exact stop_sequence and missing/invalid fields.

3) `POST /api/trips/:id/stop-times/bulk-upsert`
   - Upsert `arrive_at`, `depart_at`, `dwell_seconds` (and pickup/drop overrides if present).
   - After upsert, run `validateTripStopTimes`. If invalid, return 400 with detailed errors.
   - If valid, **auto-call**:
     a) `deriveLegsFromTrip(tripId)` → regenerate `trip_legs` (idempotent),
     b) If a query `?precompute=true` is set, call `precomputeSeatInventory(tripId)`.

4) `POST /api/trips/:id/derive-legs`
   - Before deriving, call `validateTripStopTimes`. If invalid, 400 with clear reasons:
     { code: "invalid-stop-times", errors: [...] }.

5) Derive legs = for each consecutive pair (seq i → i+1) create/update `trip_legs`:
   - leg_index = i
   - from_stop_id = stop(i).stop_id
   - to_stop_id   = stop(i+1).stop_id
   - depart_at = stop(i).depart_at
   - arrive_at = stop(i+1).arrive_at
   - duration_min derived from timestamps

6) `POST /api/trips/:id/precompute-seat-inventory`
   - Require there is at least 1 leg and a layout (effective layout = trip.layout_id || pattern.default_layout_id).
   - Create `seat_inventory` = seats × legs (idempotent if already exists).

FRONTEND
1) “Add Trip” modal:
   - After successful create, immediately open **Manage Schedule** for that trip (so user fills times).
   - Capacity shown from layout; allow override (already supported).

2) “Manage Schedule” dialog:
   - Always fetch `/api/trips/:id/stop-times` to render rows (guaranteed to exist).
   - For the first stop: show **Departure Time (required)**.
   - For middle stops: **Arrival** and **Departure** required if either is set.
   - For last stop: **Arrival** required.
   - Show inline computed “Next leg: X min” once fields are valid.
   - Buttons:
     - **Save Schedule** → calls `/bulk-upsert` with `?precompute=false`.
     - **Derive Legs** → separate button; disable if schedule invalid; on click, show success or specific errors from backend.
     - **Precompute Inventory** → disable until legs exist.
     - Option: **Save & Build (legs + inventory)** → calls `/bulk-upsert?precompute=true`.

3) Error UX:
   - If backend returns `invalid-stop-times`, list each offending row with badges like:
     “Stop #2: arrival required”, “Stop #3: times not chronological”.
   - Toast + inline red helper text per row.

4) Trip list labels:
   - For each trip, show: Pattern path (e.g., “Jakarta → Purwakarta → Bandung”), **origin depart time** (from stop seq=1), **final arrival** (from last stop) if available. If times empty, show “Schedule not set”.

ACCEPTANCE TESTS
- Create a new Trip (e.g., 8-seat). Opening “Manage Schedule” shows three rows (A, C, B).
- Enter: A depart 12:00, C arrive 12:55/depart 13:00, B arrive 14:00 → Save & Build succeeds; Derive Legs + Precompute Inventory pass.
- If C arrival is missing, Derive Legs fails with `{ code:"invalid-stop-times", errors:[...] }` and the UI marks the missing field.
- Precompute seat inventory creates seats × legs rows according to the selected layout.
