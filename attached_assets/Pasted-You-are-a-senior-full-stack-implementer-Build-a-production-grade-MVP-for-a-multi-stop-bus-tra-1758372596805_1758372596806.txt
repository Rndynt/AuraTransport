You are a senior full-stack implementer. Build a **production-grade MVP** for a **multi-stop bus/travel ticketing** system with **NO authentication** (for now). Goal: validate the **data model** and the **CSO one-page booking flow**. Use **Node 20 + Express 5 + TypeScript** for the API and **React + TypeScript (Vite)** for the UI. Keep architecture clean and modular. Model **multi-stop routes** with **segment/leg-based seat inventory**. Design for **DB-per-tenant** conceptually, but run dev with a single sample tenant DB.

NON-NEGOTIABLE RULES
- After a trip is published and has bookings, **do NOT allow changing the `stop_sequence`** (order). Time changes are OK; changing order must require a **new trip**.
- Keep code **modular by feature** (repo/service/controller). **Do NOT** dump logic into a single `storage.ts`.
- Maintain a living **`features_checklist.md`** at repo root. Every time you complete and verify a feature, **tick it** and append notes (what was built, how verified, demo URL). The agent **MUST** update this file automatically as features are finished.

⚠️ CORRECTIVE ACTIONS (AUDIT & FIX PREVIOUS AGENT OUTPUT)
- **Audit** the current codebase vs. this spec. If any module, endpoint, schema field, or UI screen is missing, **implement it now**, then **mark it** in `features_checklist.md` under a new section **“Backfill from previous agent”**.
- If a previous agent created a monolithic `storage.ts`, **remove/retire it**. Move logic into `*.repo.ts` and `*.service.ts` per module.
- **Seed data MUST match the exact case below** (Jakarta → Purwakarta → Bandung) with **correct outlets** (Jakarta & Bandung are outlets; Purwakarta is NOT). If your current seed differs, **replace it** and add a checklist note **“Seed corrected (outlets flipped)”**.

TECH & LIBS
- Backend: Node 20, Express 5, TypeScript (strict), Drizzle ORM + PostgreSQL, Zod (DTO validation), Pino (logging), Vitest + Supertest, `tsx` for dev.
- Frontend: React + TypeScript (Vite), React Router, React Query, Zustand (light state), minimal headless UI components.
- Optional: docker-compose for Postgres; in-memory HOLD store with a Redis-ready adapter behind a flag (default off).

REPOSITORY LAYOUT (monorepo-simple)
/mvp-multistop/
  backend/
    src/
      app.ts
      server.ts
      config/
        env.ts
      core/
        db.ts
        logger.ts
        errors.ts
      middleware/
        requestId.ts
        errorHandler.ts
      modules/
        stops/
          stops.schema.ts
          stops.dto.ts
          stops.repo.ts
          stops.service.ts
          stops.controller.ts
          stops.routes.ts
        outlets/
          outlets.schema.ts
          outlets.dto.ts
          outlets.repo.ts
          outlets.service.ts
          outlets.controller.ts
          outlets.routes.ts
        vehicles/
          vehicles.schema.ts
          vehicles.dto.ts
          vehicles.repo.ts
          vehicles.service.ts
          vehicles.controller.ts
          vehicles.routes.ts
        layouts/
          layouts.schema.ts
          layouts.dto.ts
          layouts.repo.ts
          layouts.service.ts
          layouts.controller.ts
          layouts.routes.ts
        tripPatterns/
          tripPatterns.schema.ts
          tripPatterns.dto.ts
          tripPatterns.repo.ts
          tripPatterns.service.ts
          tripPatterns.controller.ts
          tripPatterns.routes.ts
        patternStops/
          patternStops.schema.ts
          patternStops.dto.ts
          patternStops.repo.ts
          patternStops.service.ts
          patternStops.controller.ts
          patternStops.routes.ts
        trips/
          trips.schema.ts
          trips.dto.ts
          trips.repo.ts
          trips.service.ts
          trips.controller.ts
          trips.routes.ts
        tripStopTimes/
          tripStopTimes.schema.ts
          tripStopTimes.dto.ts
          tripStopTimes.repo.ts
          tripStopTimes.service.ts
          tripStopTimes.controller.ts
          tripStopTimes.routes.ts
        tripLegs/
          tripLegs.schema.ts
          tripLegs.repo.ts
          tripLegs.service.ts
          tripLegs.controller.ts
          tripLegs.routes.ts
        seatInventory/
          seatInventory.schema.ts
          seatInventory.repo.ts
          seatInventory.service.ts
        priceRules/
          priceRules.schema.ts
          priceRules.dto.ts
          priceRules.repo.ts
          priceRules.service.ts
          priceRules.controller.ts
          priceRules.routes.ts
        bookings/
          bookings.schema.ts
          bookings.dto.ts
          bookings.repo.ts
          bookings.service.ts
          bookings.controller.ts
          bookings.routes.ts
        payments/
          payments.schema.ts
          payments.dto.ts
          payments.repo.ts
          payments.service.ts
          payments.controller.ts
          payments.routes.ts
        printing/
          print.service.ts     # build printable payload (no real printer)
      shared/
        types.ts
        utils.ts
      test/
        integration/
          availability.test.ts
          bookings.test.ts
    drizzle.config.ts
    package.json
    tsconfig.json
    README.md
  frontend/
    src/
      app/
        routes.tsx
        providers.tsx
      shared/
        api.ts
        types.ts
        hooks/
      features/
        masters/
          StopsPage.tsx
          OutletsPage.tsx
          VehiclesPage.tsx
          LayoutsPage.tsx
          TripPatternsPage.tsx
          TripsPage.tsx
          PriceRulesPage.tsx
        cso/
          CsoPage.tsx
          components/
            TripPicker.tsx
            OdPicker.tsx
            SeatMap.tsx
            PassengerForm.tsx
            PaymentPanel.tsx
            PrintPreview.tsx
          hooks/
            useSeatHold.ts
            useBookingFlow.ts
    index.html
    vite.config.ts
    package.json
    tsconfig.json
    README.md
  package.json
  features_checklist.md
  README.md

DATA MODEL (Drizzle) — create EXACTLY these tables/fields
1) stops: id(uuid pk), code(text unique), name(text), city(text?), lat(numeric(9,6)?), lng(numeric(9,6)?), is_outlet(boolean default false), created_at(timestamptz)
2) outlets: id(uuid pk), stop_id(uuid fk→stops unique), name(text), address(text?), phone(text?), printer_profile_id(text?), created_at(ts)
3) vehicles: id, code(unique), plate(unique), layout_id(fk), capacity(int), notes(text?), created_at(ts)
4) layouts: id, name, rows(int), cols(int), seat_map(jsonb[{seat_no,row,col,class?,disabled?}]), created_at(ts)
5) trip_patterns: id, code(unique), name, vehicle_class(text?), default_layout_id(fk?), active(bool), tags(text[]), created_at(ts)
6) pattern_stops: id, pattern_id(fk), stop_id(fk), stop_sequence(int UNIQUE(pattern_id,stop_sequence)), dwell_seconds(int default 0), created_at(ts). Indexes: (pattern_id,stop_sequence),(pattern_id,stop_id)
7) trips: id, pattern_id(fk), service_date(date), vehicle_id(fk), layout_id(fk?), capacity(int), status(enum: scheduled|canceled|closed), channel_flags(jsonb), created_at(ts). Indexes: (pattern_id,service_date),(status,service_date)
8) trip_stop_times: id, trip_id(fk), stop_id(fk), stop_sequence(int UNIQUE(trip_id,stop_sequence)), arrive_at(ts?), depart_at(ts?), dwell_seconds(int default 0). Index: (trip_id,stop_sequence)
9) trip_legs: id, trip_id(fk), leg_index(int UNIQUE(trip_id,leg_index)), from_stop_id(fk), to_stop_id(fk), depart_at(ts), arrive_at(ts), duration_min(int). Indexes: (trip_id,leg_index),(trip_id,from_stop_id,to_stop_id)
10) seat_inventory: id, trip_id(fk), seat_no(text), leg_index(int), booked(boolean default false), hold_ref(text?). UNIQUE(trip_id,seat_no,leg_index). Indexes: (trip_id,leg_index,booked),(trip_id,seat_no)
11) price_rules: id, scope(enum: pattern|trip|leg|time), pattern_id(uuid?), trip_id(uuid?), leg_index(int?), rule(jsonb), valid_from(ts?), valid_to(ts?), priority(int default 0). Indexes: (scope,pattern_id),(scope,trip_id),(valid_from,valid_to)
12) bookings: id, trip_id(fk), origin_stop_id(fk), destination_stop_id(fk), origin_seq(int), destination_seq(int), outlet_id(fk?), channel(enum: CSO|WEB|APP|OTA default 'CSO'), status(enum: pending|paid|canceled|refunded default 'pending'), total_amount(numeric(12,2)), currency(text default 'IDR'), created_by(text?), created_at(ts). Indexes: (trip_id),(status,trip_id),(outlet_id,created_at)
13) passengers: id, booking_id(fk), full_name(text), phone(text?), id_number(text?), seat_no(text), fare_amount(numeric(12,2)), fare_breakdown(jsonb?). Index: (booking_id)
14) payments: id, booking_id(fk), method(enum: cash|qr|ewallet|bank), amount(numeric), status(enum: pending|success|failed default 'success'), provider_ref(text?), paid_at(ts). Index: (booking_id,status)
15) print_jobs: id, booking_id(fk), status(enum: queued|sent|failed default 'queued'), attempts(int default 0), last_error(text?), created_at(ts)

BACKEND BEHAVIOR
- **Seed demo (MUST match exactly)**
  - Stops: **A=Jakarta (outlet=true)**, **C=Purwakarta (outlet=false)**, **B=Bandung (outlet=true)**.
  - Outlets: **Jakarta & Bandung only**. **Do NOT** create an outlet for Purwakarta.
  - Layout: 12 seats grid.
  - Pattern: `AB_via_C` with `A(1), C(2), B(3)`.
  - Trip: today at **10:00 WIB**; stop times: A depart 10:00, C arrive 10:55 / depart 11:00, B arrive 12:00. Use `+07:00` timezone suffix to avoid UTC drift.
  - After creating stop times: **derive `trip_legs`** (leg1 A→C, leg2 C→B) and **precompute `seat_inventory`** (12×2).
  - Add price rule: base per leg (e.g., 50k IDR).
- Implement **service-level guard**: if a trip has any booking, reject mutations that reorder `stop_sequence` for that trip (return clear error).
- **Seat HOLD interface**:
  - `InMemoryHoldStore` (default): atomic multi-key acquire for all legs in a range; TTL **120s**.
  - `RedisHoldStore` skeleton behind `USE_REDIS=false` (not required to run).
- Pricing: `pricing.service.ts` exposes `quoteFare(tripId, originSeq, destinationSeq, seatClass?)`. Default: sum per-leg base, then simple rules from `price_rules`.

API ENDPOINTS
- Masters CRUD: `stops`, `outlets`, `vehicles`, `layouts`, `tripPatterns`, `patternStops`, `trips`, `tripStopTimes`, `priceRules`.
- Trip derivations:
  - `POST /api/trips/:id/derive-legs`
  - `POST /api/trips/:id/precompute-seat-inventory`
- CSO:
  - `GET  /api/trips?date=YYYY-MM-DD`
  - `GET  /api/trips/:id/stop-times`
  - `GET  /api/trips/:id/seatmap?originSeq=1&destinationSeq=3` (layout + seat availability for OD; seat available **iff** all legs in range are free)
  - `POST /api/holds`  body: `{ tripId, seatNo, originSeq, destinationSeq, ttlSeconds? }` (atomically hold all legs)
  - `POST /api/bookings`  header: `Idempotency-Key`  
    body:
    {
      tripId, outletId, originStopId, destinationStopId, originSeq, destinationSeq,
      passengers: [{ fullName, phone?, idNumber?, seatNo }],
      payment: { method, amount }
    }
    flow:
      1) validate OD & legs range,
      2) ensure seat-legs are **unbooked** and **held** by this request,
      3) transaction: set `seat_inventory.booked=true` for all seat-legs; insert booking + passengers + payment (status 'paid' for MVP),
      4) enqueue `print_jobs`; return printable payload.

TESTS (Vitest + Supertest)
- `availability.test.ts`: booking A→B seat 4 marks leg1 & leg2 booked; subsequent A→C or C→B seat 4 should be unavailable.
- `bookings.test.ts`: Idempotency-Key enforced; guard prevents stop order change when bookings exist.
- `seed.test.ts`: verify **outlet flip is correct** (JKT=true, PWK=false, BDG=true) and **no Outlet row for Purwakarta**.

FRONTEND (Vite + React + TS)
- Routes: `/masters` (tabs/cards to each master CRUD), `/cso` (single-page booking/issue).
- Masters UI: tables/forms; for **pattern stops**, support drag reorder or explicit sequence. In Trips editor: buttons **Derive legs** and **Precompute seat inventory**.
- CSO one-page flow:
  1) Outlet Picker (should list **only stops with `is_outlet=true`** → JKT, BDG),
  2) Trip Picker (by date),
  3) OD Picker (from ordered stops; resolve `originSeq`/`destinationSeq`),
  4) SeatMap (segment-aware availability for chosen OD; selecting a seat triggers `POST /api/holds` with TTL badge),
  5) Passenger Form,
  6) Payment Panel (mock),
  7) Issue & Print Preview.
- State: `useSeatHold` (holds lifecycle), `useBookingFlow` (steps in one page).
- Keyboard UX: arrow navigation on seat grid; Enter to select; helpful shortcuts (Alt+F find, Alt+P pay).

SCRIPTS
- Backend: `dev` (tsx), `db:push` (Drizzle), `seed` (run seed, derive legs, precompute inventory), `test` (Vitest).
- Frontend: `dev` (Vite), `build` (Vite build).
- Root: optional concurrently.

README
- Backend README: quickstart, env, multi-stop→legs→seat_inventory diagram, invariant “no stop order change after bookings”, seed instructions.
- Frontend README: how to use CSO page end-to-end.

ACCEPTANCE CRITERIA (the agent MUST update `features_checklist.md` as items are completed)
- [ ] Drizzle schemas match exactly all tables/fields above.
- [ ] **Seed corrected**: Jakarta(outlet=✓), Purwakarta(outlet=✗), Bandung(outlet=✓); Outlets exist for Jakarta & Bandung only; pattern A(1)→C(2)→B(3); trip 10:00 WIB; legs derived; seat inventory precomputed.
- [ ] Masters CRUD working (stops/outlets/vehicles/layouts/tripPatterns/patternStops/trips/tripStopTimes/priceRules).
- [ ] Trip legs derivation endpoint works; seat inventory precompute works.
- [ ] CSO page completes **Outlet → Trip → OD → Seat → Passenger → Payment → Issue (Print Preview)** on a single screen.
- [ ] Availability is **segment-aware**; booking A→B seat 4 blocks leg1 & leg2; A→C or C→B seat 4 becomes unavailable.
- [ ] HOLD TTL (120s) prevents race; booking requires held seats.
- [ ] Guard blocks stop order changes on trips with existing bookings.
- [ ] Code modular by feature; no monolithic storage file.
- [ ] **Backfill from previous agent** section in `features_checklist.md` lists each fixed/missing feature with a check and note.
